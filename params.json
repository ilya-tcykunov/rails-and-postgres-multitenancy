{"name":"Rails-and-postgres-multitenancy","tagline":"","body":"# Ruby on Rails и PostgreSQL: мультидоменность\r\n\r\nВ интернете можно найти много похожих между собой статей, в которых говорится, как реализоать мультидоменность приложения на RoR, используя схемы PostgreSQL. Например, [эта](http://railscasts.com/episodes/389-multitenancy-with-postgresql?view=asciicast) и [эта](http://jerodsanto.net/2011/07/building-multi-tenant-rails-apps-with-postgresql-schemas/). Лично я в качестве основы использовал код из railscast. Но при практической реализации какого-либо варианта возникает множество проблем. В данной статье будут описаны некоторые из таких проблем и мои способы их решения.\r\n\r\n## Кеширование в переменных\r\n\r\nЧтобы минимизировать количесвтво обращений к базе данных или чтобы лишний раз не выполнять инициализацию одних и тех же объектов неоторые вещи выгодно рассчитывать один раз и инициализировать, например, так: \r\n\t\r\n    def parse(*args)\r\n      @connection ||= Connection.new\r\n      @connection.parse\r\n    end\r\n\r\nТакое решение можно назвать кешированием в переменных, и при создании мультидоменности за этим нужно пристально следить. Вот [статья](http://timnew.me/blog/2012/07/17/use-postgres-multiple-schema-database-in-rails/)<a href=\"http://timnew.me/blog/2012/07/17/use-postgres-multiple-schema-database-in-rails/\">статья</a>, в которой автор описывает свой опыт, когда он ошибся, используя для задания search_path прямым обращеним к базе данных через\r\n\r\n    ActiveRecord::Base.connection.execute \"SET search_path TO #{schema};\"\r\n\r\nвместо использования\r\n\r\n    ActiveRecord::Base.connection.schema_search_path schema\r\n\r\nВ ядре Rails используется как раз второй вариант, в котором происходит кеширование search_path в переменной. Соответственно, джемы часто не знали, что search_path в базе другой, что и приводило к ошибкам.\r\n\r\n## Расширения postgresql и индексы\r\n\r\nПри создании таблиц индекcы можно создавать тремя способами:\r\n\r\n    create_table :test do |t|\r\n      t.integer :data, index: true\r\n      t.integer :start_time\r\n      t.integer :end_time\r\n    end\r\n\r\n    add_index :test, :start_time\r\n    execute 'create index end_time_index on test (end_time integer);'\r\n\r\nПри вызове add_index (в первом случае этот метод так же вызывается), происходит такая [проверка](http://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/PostgreSQLAdapter/SchemaStatements.html#method-i-index_name_exists-3F):\r\n\r\n    def index_name_exists?(table_name, index_name, default)\r\n      exec_query(\"SELECT COUNT(*)\r\n        FROM pg_class t\r\n        INNER JOIN pg_index d ON t.oid = d.indrelid\r\n        INNER JOIN pg_class i ON d.indexrelid = i.oid\r\n        WHERE i.relkind = 'i'\r\n        AND i.relname = '#{index_name}'\r\n        AND t.relname = '#{table_name}'\r\n        AND i.relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname = ANY (current_schemas(false)) )\r\n      \", 'SCHEMA').rows.first[0].to_i > 0\r\n    end\t\t\r\n\r\nТаким образом смотрится, есть ли индекс с указанным названием в <big>любой</big> схеме, а не только в первой из списка search_path. Алгоритм создания нового домена следующий:\r\n\r\n* Создать доменную схему\r\n* Включить её в search_path\r\n* Выполнить миграцию\r\n\r\nНо миграция может завершиться с ошибкой, потому что search_path на этом этапе обычно 'tenant1,public', и index_name_exists? будет true, если в public схеме уже есть какая-либо таблица с индексом.\r\n\r\nВариантов выхода из ситуации два.\r\n\r\nПервый - во всех миграциях не использовать index: true при создании таблиц и add_index, а использовать execute('create index ...'). Этот вариант не удобен: банально долго писать. К тому же, что если мультидоменность создаётся на уже существующем проекте с большим количеством уже готовых миграций, то в них во всех придётся переписывать создание индексов.\r\n\r\nВторой вариант - не добавлять public схему в search_path при миграциях. То есть search_path в нашем случае будет 'tenant1'. Но если не добавлять public, возникает другая проблема. По умолчанию расширения postgres ставятся в public схему, и поэтому может возникнуть ошибка, что, к примеру, тип данных 'hstore' не найден (при использовании расшения hstore). Кроме того нельзя поставить расширение ещё раз, но в другую схему (tenant1). Такова особенность postgres: расширение ставится в какую-то схему, но повторно савить его в другие нельзя. Решение этой проблемы - ставить расширения PostgreSQL в отдельную схему, и постоянно включать её в search_path.\r\n\r\nЯ решил воспользоваться вторым вариантом, создал специальную схему для установки в неё расширений и подключаю её всегда. Перед миграцией search_path='tenant1,extensions', во время обычной работы - 'tenant1,oublic,extensions'. Настройку базы и ролей делаю так:\r\n\r\n    sudo -u postgres psql -c \"CREATE SCHEMA extensions\" template1\r\n    sudo -u postgres psql -c \"CREATE EXTENSION hstore WITH SCHEMA extensions\" template1\r\n    sudo -u postgres psql -c \"CREATE EXTENSION pg_trgm WITH SCHEMA extensions\" template1\r\n    sudo -u postgres psql -c 'ALTER ROLE postgres SET search_path TO \"$user\", public, extensions'\r\n    sudo -u postgres psql -c \"CREATE ROLE prj WITH LOGIN PASSWORD 'qwepoiqwe'\"\r\n    sudo -u postgres psql -c 'ALTER ROLE prj SET search_path TO \"$user\", public, extensions'\r\n    sudo -u postgres psql -c \"GRANT USAGE ON SCHEMA extensions TO prj\" template1\r\n\r\n## Создание тамблиц в доменных и публичной схемах\r\n\r\nTODO\r\n\r\nself.table_name = 'public.tenants'\r\n\r\nstructure.sql\r\n\t\r\n## Кеш\r\n\r\nПри использовании полноценного кеша проблемы такие же, как и при применении кеширования в переменных. Кроме того, кеш между доменами следует разделять. Сделать это можно двумя способами.\r\n\r\nПервый - это вручную добавлять домен к названиям ключей. Недостаток этого варианта в том, сторонние библиотеки как использовали старые названия ключей, так и будут их использовать. Поэтому, чтобы всё заработало, нужно тщательно пропатчить библиотеки ядра, которые связаны с кешированием.\r\n\r\nВторой вариант - использовать неймспейсы (если драйвер кеша их поддерживает). Я использую dalli, в котором можно задавать неймспейс при инициализации, и сам неймспейс - это просто префикс, автоматически добавляемый к ключам. К сожалению, смена неймспейса на лету не поддерживается, поэтому для решения можно написать патч, добаваив к классу Dalli::Client аксессор options, либо напрямую менять переменную инстанса. В итоге для исполнения кода в рамках домена я делаю так:\r\n\r\n    def scope_schema(*paths, &block)\r\n      original_search_path = self.class.connection.schema_search_path\r\n      self.class.connection.schema_search_path = [schema, *paths, 'extensions'].join(\",\")\r\n      if !Rails.cache.is_a?(ActiveSupport::Cache::DalliStore) && !Rails.env.test?\r\n        raise 'Schema scope cache error'\r\n      end\r\n      if Rails.cache.is_a?(ActiveSupport::Cache::DalliStore)\r\n        original_cache_options = Rails.cache.dalli.instance_variable_get(:@options)\r\n        Rails.cache.dalli.instance_variable_set(:@options, original_cache_options.merge({namespace: schema}))\r\n      end\r\n      block.call(self)\r\n    ensure\r\n      if Rails.cache.is_a?(ActiveSupport::Cache::DalliStore)\r\n        Rails.cache.dalli.instance_variable_set(:@options, original_cache_options)\r\n      end\r\n      self.class.connection.schema_search_path = original_search_path\r\n    end\r\n\r\n## Инициализаторы\r\n\r\nКод из директории config содержит настройки для всего приложения. В случае мультидоменности у нас как бы нескольк разных приложений, поэтому всё из config подлежит пересмотру на предмет того, что является общим для всех приложений, а что для каждого домена своё. Рассмотрим пример с настрокой почты.\r\n\r\nВ простом случае без мультидоменности какие-то настройки почты можно вынести в application.rb. К примеру, в этом файле можно указать config.action_mailer.default_options[:from]. В случае мультидоменности для каждого домена, вероятно, придётся указывать разных отправителей. Чтобы это сделать, имеет смысл создать таблицу настроек в базе данных или кеше, где будут храиниться настройки домена. В каждой доменной схеме разумно создать свою таблицу настроек. Настройки из таблицы следует извлекать каждый раз перед отправкой письма. Это можно сделать как в мейлере:\r\n\r\n    class UserMailer < ActionMailer::Base\r\n      default Setting.mail_settings[:default_fields]\r\n    end\r\n\r\nтак и пропатчив ActionMailer::Base (если мейлеров много)\r\n\r\n    require 'active_support/concern'\r\n\r\n    module ActionMailerBasePatch\r\n      extend ActiveSupport::Concern\r\n\r\n      included do\r\n        default Setting.mail_settings[:default_fields]\r\n      end\r\n    end\r\n\r\n    ActionMailer::Base.send(:include, ActionMailerBasePatch)\r\n\t\r\n## Заключение\r\n\r\nОрганизация мультидоменности - это скурпулёзный процесс.\r\n\r\nTODO","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}